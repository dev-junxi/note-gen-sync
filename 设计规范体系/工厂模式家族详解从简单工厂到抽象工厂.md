# 工厂模式家族详解：从简单工厂到抽象工厂

工厂模式是创建型设计模式中最常用也最强大的模式之一。今天我就来系统梳理工厂模式家族的各个成员，从简单工厂到抽象工厂，帮你彻底掌握这些模式的区别和应用场景。

## 一、工厂模式基础篇：简化对象创建

工厂模式的核心思想是**封装对象的创建过程**，使调用者无需关心具体实现。我们先从最简单的三种工厂模式开始。

### 1. 普通工厂模式（Simple Factory）

这是最简单的工厂模式，通过传入参数决定创建哪个对象。

```java
// 抽象产品
public interface Animal {
    void speak();
}

// 具体产品
public class Dog implements Animal {
    public void speak() {
        System.out.println("Dog barks");
    }
}

public class Cat implements Animal {
    public void speak() {
        System.out.println("Cat meows");
    }
}

// 工厂类
public class AnimalFactory {
    public Animal createAnimal(String type) {
        if ("dog".equalsIgnoreCase(type)) {
            return new Dog();
        } else if ("cat".equalsIgnoreCase(type)) {
            return new Cat();
        } else {
            throw new IllegalArgumentException("Unknown type");
        }
    }
}
```

**优点**：简单易用，适合小型项目  
**缺点**：违反开闭原则，每次新增产品都要修改工厂方法

### 2. 多方法工厂模式

为每种产品提供专门的创建方法，代码更清晰。

```java
public class AnimalFactory {
    public Animal createDog() {
        return new Dog();
    }

    public Animal createCat() {
        return new Cat();
    }
}
```

**优点**：职责单一，方法明确  
**缺点**：工厂类会随着产品增多而膨胀

### 3. 静态工厂方法模式

将工厂方法改为静态的，使用更方便。

```java
public class AnimalFactory {
    public static Animal createDog() {
        return new Dog();
    }

    public static Animal createCat() {
        return new Cat();
    }
}
```

**优点**：调用简单，性能略优  
**缺点**：不支持继承和多态

## 二、工厂模式进阶篇：GoF正式模式

上述三种都是工厂模式的简化版本，下面介绍GoF提出的两种正式工厂模式。

### 1. 工厂方法模式（Factory Method Pattern）

**定义**：定义一个创建对象的接口，让子类决定实例化哪一个类。

```java
// 产品接口
public interface Animal {
    void speak();
}

// 具体产品
public class Dog implements Animal {
    public void speak() {
        System.out.println("Dog barks");
    }
}

// 抽象工厂
public abstract class AnimalFactory {
    public abstract Animal createAnimal();
}

// 具体工厂
public class DogFactory extends AnimalFactory {
    public Animal createAnimal() {
        return new Dog();
    }
}
```

**结构图**：
```
┌────────────┐      ┌────────────────┐
│  Animal    │◄─────│   Dog、Cat 等  │
└────────────┘      └────────────────┘
      ▲
      │
┌────────────┐      ┌────────────────────┐
│ AnimalFactory │◄───│ DogFactory / CatFactory │
└────────────┘      └────────────────────┘
```

**优点**：
- 遵循开闭原则：新增产品不修改原有代码
- 支持继承和多态，结构清晰

**缺点**：
- 每新增一个产品类，就要新增一个工厂类

### 2. 抽象工厂模式（Abstract Factory Pattern）

**定义**：提供一个创建一系列相关或相互依赖对象的接口。

```java
// 抽象产品
public interface Button {
    void render();
}

public interface Textbox {
    void render();
}

// 具体产品(Windows系列)
public class WinButton implements Button {
    public void render() {
        System.out.println("Render Windows Button");
    }
}

// 抽象工厂
public interface GUIFactory {
    Button createButton();
    Textbox createTextbox();
}

// 具体工厂(Windows)
public class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }
    public Textbox createTextbox() {
        return new WinTextbox();
    }
}
```

**优点**：
- 一次生成一组相关产品，保证一致性
- 满足开闭原则，新增产品族容易

**缺点**：
- 产品族扩展困难(新增产品类型需要修改所有工厂)

## 三、模式对比与选择指南

| 模式 | 是否支持扩展 | 是否支持多产品 | 是否支持多产品族 | 使用场景 |
|------|------------|--------------|----------------|---------|
| 工厂方法模式 | ✅ 易扩展 | ❌ 一次一种产品 | ❌ | 灵活创建某类对象 |
| 抽象工厂模式 | ✅ 可扩产品族 | ✅ 多产品 | ✅ | UI风格切换、数据库切换 |

**选择建议**：
- 简单项目：静态工厂方法
- 单一产品扩展：工厂方法模式
- 产品族需求：抽象工厂模式

## 四、现实世界举例

假设你在开发一个跨平台应用：

1. **工厂方法**：用于创建单个UI组件，比如创建一个按钮
2. **抽象工厂**：用于创建整套UI组件(按钮、文本框、复选框)，确保它们风格一致(Mac或Windows)

工厂模式就像一家餐厅的后厨系统：
- 简单工厂：一个大厨负责所有菜品
- 多方法工厂：每位大厨专攻一道菜
- 工厂方法：设立不同厨房(中餐/西餐厨房)
- 抽象工厂：提供完整套餐(中餐套餐/西餐套餐)